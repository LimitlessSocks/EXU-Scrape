const ExampleImages = [
    "https://ms.yugipedia.com//2/2e/BrotherhoodoftheFireFistSwan-MADU-EN-VG-artwork.png",
    "https://yugipedia.com/wiki/Special:Redirect/file/AleistertheInvoker-MADU-EN-VG-artwork.png?utm_source=bastion",
    "https://yugipedia.com/wiki/Special:Redirect/file/TreebornFrog-MADU-EN-VG-artwork.png?utm_source=bastion",
    "https://i.redd.it/plvo7j0qcwh51.jpg",
];
const ExampleNames = [
    "Fire Fist",
    "Invoked",
    "Frogs",
    "Other",
];
const ExampleRatios = [
    4,
    3,
    2,
    5,
];

const addDeck = (initialRender = true) => {
    let decksContainer = document.getElementById("decksContainer");

    let myIndex = decksContainer.children.length;

    let deckDiv = document.createElement("fieldset");
    deckDiv.classList.add("deck");
    let legend = document.createElement("legend");
    legend.textContent = "Deck #" + (1 + myIndex);
    deckDiv.appendChild(legend);

    let deckNameInput = document.createElement("input");
    deckNameInput.setAttribute("type", "text");
    deckNameInput.setAttribute("placeholder", "Enter Deck Name");
    deckNameInput.classList.add("deckName");
    deckNameInput.value = ExampleNames[myIndex] ?? "";
    let deckNameLabel = document.createElement("label");
    deckNameLabel.textContent = "Deck Name: ";
    let deckNameParagraph = document.createElement("p");
    deckNameParagraph.appendChild(deckNameLabel);
    deckNameParagraph.appendChild(deckNameInput);
    deckDiv.appendChild(deckNameParagraph);

    let timesPlayedInput = document.createElement("input");
    timesPlayedInput.setAttribute("type", "number");
    timesPlayedInput.value = ExampleRatios[myIndex] ?? 1;
    timesPlayedInput.setAttribute("placeholder", "Amount");
    timesPlayedInput.classList.add("timesPlayed");
    let timesPlayedLabel = document.createElement("label");
    timesPlayedLabel.textContent = "Times Played: ";
    let timesPlayedParagraph = document.createElement("p");
    timesPlayedParagraph.appendChild(timesPlayedLabel);
    timesPlayedParagraph.appendChild(timesPlayedInput);
    deckDiv.appendChild(timesPlayedParagraph);

    let deckImageInput = document.createElement("input");
    deckImageInput.setAttribute("type", "text");
    deckImageInput.setAttribute("placeholder", "Thumbnail");
    deckImageInput.value = ExampleImages[myIndex] ?? "";
    deckImageInput.classList.add("deckImage");
    let deckImageLabel = document.createElement("label");
    deckImageLabel.textContent = "Deck Image: ";
    let deckImageParagraph = document.createElement("p");
    deckImageParagraph.appendChild(deckImageLabel);
    deckImageParagraph.appendChild(deckImageInput);
    deckDiv.appendChild(deckImageParagraph);

    let deckRemoveButton = document.createElement("button");
    deckRemoveButton.textContent = "Remove Deck";
    deckRemoveButton.addEventListener("click", function(ev) {
        deckDiv.remove();
        render();
        
    });
    deckDiv.appendChild(deckRemoveButton);
    
    let moveUpButton = document.createElement("button");
    moveUpButton.textContent = "⬆️";
    moveUpButton.addEventListener("click", function(ev) {
        let myIdx = [...decksContainer.children].indexOf(deckDiv);
        if(myIdx === 0) {
            return;
        }
        let targetIdx = myIdx - 1;
        deckDiv.remove();
        decksContainer.insertBefore(deckDiv, decksContainer.children[targetIdx]);
        render();
    });
    deckDiv.appendChild(moveUpButton);
    let moveDownButton = document.createElement("button");
    moveDownButton.textContent = "⬇️";
    moveDownButton.addEventListener("click", function(ev) {
        let myIdx = [...decksContainer.children].indexOf(deckDiv);
        if(myIdx + 1 === decksContainer.children.length) {
            return;
        }
        let targetIdx = myIdx + 1;
        deckDiv.remove();
        decksContainer.insertBefore(deckDiv, decksContainer.children[targetIdx]);
        render();
    });
    deckDiv.appendChild(moveDownButton);

    decksContainer.appendChild(deckDiv);

    for(let input of deckDiv.querySelectorAll("input")) {
        input.addEventListener("change", render);
    }
    
    if(initialRender) {
        render();
    }
};

const loadImage = url => new Promise((resolve, reject) => {
    let img = new Image();
    img.src = url;
    img.onload = function () {
        resolve(this);
    };
});

const LOGO_SRC = {
    exu: "./res/logo.png",
    sff: "./res/sff-logo.png",
};
const ATTRIBUTION = {
    exu: "discord.gg/extinctionunleashed",
    sff: "discord.gg/Za2tpNmj8m",
};

// Generated by ChatGPT, and tested extensively (https://jsfiddle.net/7qv83Lbx/1/).
// I'm not sure why or if we need to calculate the angleBisector here
// (I suspect this is a holdover from me showing it findSectorCenter as a reference frame for the input format),
// but my naive attempt to factor it doesn't work, and I don't care enough to think about geometry at present.
const isPointInSector = (xTest, yTest, centerX, centerY, radius, startAngle, widthAngle) => {
    // Calculate angle between center of sector and test point
    let dx = xTest - centerX;
    let dy = yTest - centerY;
    let angleToPoint = Math.atan2(dy, dx);
    if (angleToPoint < 0) angleToPoint += 2 * Math.PI; // Convert negative angle to positive

    // Calculate angle bisector
    let angleBisector = (startAngle + (startAngle + widthAngle)) / 2;
    
    // Check if angle to point is within sector angle range
    let angleDifference = Math.abs(angleToPoint - angleBisector);
    if (angleDifference > Math.PI) {
        angleDifference = 2 * Math.PI - angleDifference;
    }
    let isInAngleRange = angleDifference <= widthAngle / 2;

    // Calculate distance between center and test point
    let distanceToCenter = Math.sqrt(dx * dx + dy * dy);

    // Check if the point is within the sector
    return isInAngleRange && distanceToCenter <= radius;
};

const findSectorCenter = (canvas, ctx, radius, startAngle, widthAngle) => {
    let centerX = canvas.width / 2;
    let centerY = canvas.height / 2;
    
    let angleBisector = (startAngle + (startAngle + widthAngle)) / 2;
    
    return {
        x: centerX + Math.cos(angleBisector) * radius / 2,
        y: centerY + Math.sin(angleBisector) * radius / 2,
    };
};

const render = async () => {
    // TODO: save image state, or at least use existing manager
    console.log("Render start");
    const format = $("[name=format]:checked").val();
    let allFormats = [...$("[name=format]")].map(e => $(e).val());
    
    allFormats.forEach(fmt => {
        $("#output").toggleClass(fmt, fmt === format);
    });
    
    $(".exuLogo").attr("src", LOGO_SRC[format]);
    $(".attribution").text(ATTRIBUTION[format]);
    $(".eventName").text($("input[data-target='eventName']").val());
    $(".eventDate").text($("input[data-target='eventDate']").val());
    
    const canvas = document.getElementsByTagName("canvas")[0];
    const ctx = canvas.getContext("2d");
    let manager = DragManager.for(ctx);
    manager.reset();

    manager.clearCanvas();

    let centerX = canvas.width / 2;
    let centerY = canvas.height / 2;

    let radius = canvas.width / 2;

    let sections = [...$(".timesPlayed")].map(e => +$(e).val());
    let sum = sections.reduce((p, c) => p + c);

    let urls = [...$(".deckImage")].map(e => $(e).val() || "https://cdn3.vectorstock.com/i/1000x1000/96/47/error-pixel-glitch-vector-20409647.jpg");
    let images = await Promise.all(urls.map(url => loadImage(url)));
    let deckNames = [...$(".deckName")].map(e => $(e).val());

    manager.append(new Renderable(ctx, function () {
        // draw background circle
        this.ctx.fillStyle = "gold";
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        this.ctx.fill();
    }));

    // draw inner sections
    let innerRadius = radius - 10;
    let startAngle = -Math.PI / 2;
    let pushOutDistance = 50;
    let starts = [];
    // layering
    let handles = [];
    let texts = [];
    let strokes = [];
    sections.forEach((rep, idx) => {
        starts.push(startAngle);
        let img = images[idx];
        let name = deckNames[idx] || "(unnamed)";
        console.log("NAME:", name);
        let widthAngle = rep / sum * 2 * Math.PI;
        let { x: arcCenterX, y: arcCenterY } = findSectorCenter(canvas, ctx, innerRadius, startAngle, widthAngle);
        // variable binding!!!
        let myStartAngle = startAngle;
        startAngle += widthAngle;
        console.log(centerX, centerY, ";;;", arcCenterX, arcCenterY);

        let handleWidth = img.width;
        let handleOrigin = {
            x: arcCenterX - handleWidth / 2,
            y: arcCenterY - handleWidth / 2,
        };
        let handle = new DraggableElement({
            ctx,
            width: handleWidth,
            height: handleWidth,
            x: handleOrigin.x,
            y: handleOrigin.y,
        });

        handle.clipFunction = (x, y) => isPointInSector(x, y, centerX, centerY, innerRadius, myStartAngle, widthAngle);
        //.setBaseBorder("purple");

        // /*
        manager.append(new Renderable(ctx, function () {
            // console.log("Rendering:", idx, img, name, "@", myStartAngle);
            // section background
            this.ctx.beginPath();
            this.ctx.moveTo(centerX, centerY);
            this.ctx.arc(centerX, centerY, innerRadius, myStartAngle, myStartAngle + widthAngle);
            this.ctx.lineTo(centerX, centerY);
            this.ctx.closePath();
            // fill with image
            this.ctx.save();
            this.ctx.fillStyle = this.ctx.createPattern(img, "no-repeat");
            let dx = handle.x - handleOrigin.x;
            let dy = handle.y - handleOrigin.y;
            this.ctx.translate(-img.width / 2 + dx, -img.height / 2 + dy);
            this.ctx.translate(arcCenterX, arcCenterY);
            this.ctx.scale(handle.zoomRatio, handle.zoomRatio);
            this.ctx.fill();
            this.ctx.restore();
        }));
        // */

        handles.push(handle);

        /*
        ctx.font = "bold 36px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "white";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.fillText("HELLO!", arcCenterX, arcCenterY);
        ctx.strokeText("HELLO!", arcCenterX, arcCenterY);
        */

        texts.push(new DraggableText({
            ctx,
            text: name,
            x: arcCenterX,
            y: arcCenterY,
        }).offsetCenter());

        // draw strokes
        strokes.push(new Renderable(ctx, function () {
            ctx.strokeStyle = "gold";
            ctx.lineWidth = 5;
            ctx.lineCap = "round";
            sections.forEach((rep, idx) => {
                let start = starts[idx];
                let outerX = centerX + Math.cos(start) * innerRadius;
                let outerY = centerY + Math.sin(start) * innerRadius;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(outerX, outerY);
                ctx.closePath();
                ctx.stroke();
            });
        }));
    });

    manager.append(...strokes);
    manager.append(...handles);
    manager.append(...texts);

    manager.render();
};

window.addEventListener("load", function () {
    const DEFAULT_DECK_COUNT = 4;
    for(let i = 0; i < DEFAULT_DECK_COUNT; i++) {
        addDeck(false);
    }
    
    $("#chartInfo input").on("change", render);
    render();
});
